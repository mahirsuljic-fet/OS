Kernel -> User   tranzicija se vrsi pomocu privilegovane instrukcije.
User   -> Kernel tranzicija se NE vrsi pomocu instrukcije nego pomocu prekida, iznimki ili sistemskih poziva.

Cilj je da se kernel sto manje (krace) koristi, jer sto manje vremena kernel potrosi koristeci procesor to je sistem responzivniji.
Kernel konfigurise MMU i tak ose stvara iluzija da svaki proces ima cijeli adresni prostor.
Taj cijeli adresni prostor se naziva virtuelni adresni prostor.
Zadatak MMU je da mapira virtuelni adresni prostor u fizicki adresni prostor (stvarni RAM).
Virtuelnih adresnih prostora u datom trenutku ima onoliko koliko ima procesa na operativnom sistemu, a fizickih je samo jedan.
Kernel cak i sam sebi stvara tu iluziju (da ima cijeli adresni prostor).
Bez MMU ne moze se ni imati operativni sistem.
Preuslov za operativni sistem je dakle MMU i da postoje privilegovani i neprivilegovani modovi rada procesora.
Racunari koji nemaju MMU su mikrokontroleri i na njima se izvrsava samo jedan program.

Na i386 platformi real (20 bitni) i protected (32 bitni) mode nisu kao user i kernel mod.
Ako je u real modu radi kao Intel 8086, a u protected modu radi kao i386.
Najnoviji intel procesori imaju jos jedan mod operacije (64 bitni).
Kad procesor dobije napon on je u real modu. Zelimo sto brze da predjemo u protected mode.
Moramo znat real mode jer u njemu moramo konfigurisati racunar (MMU i sve) kako bi prelazak u protected mode bio uspjesan i radio kako treba.
U real modu sve instrukcije su privilegovane (nema protekciju/izolaciju).
Paging je po defaultu deaktiviran, tako da je potrebno aktivirat, a prije toga je potrebno ga konfigurisat.

Danas CPU unutar sebe ima integriran MMU.
Logicka adresa je adresa iz virtuelnog memorijskog prostora.
Segmentacijom se logicka adresa pretvara u lineranu adresu, a ona se stranicinjenjem pretvara u fizicku adresu.
CHIPSET obicno ima dva bridge-a (northbridge i southbridge).
Na northbridge su spojeni CPU, RAM i GPU, te je on zasluzen za preusmjerivanje.
Northbridge takodjer ima konekciju na southbridge.
Na northbridge su spojeni USB kontroler (svi spori uredjaji: tastatura, mis, webcam, memorijska kartica...) i slicno.

Segmentni registi su 16-bitni, cak i na modernih procesorima.
Segmentni registri (veoma bitni, svaki program ih koristi):
%cs -> code segment       }
%ss -> stack segment      } VEOMA BITNI
%ds -> data segment       }
%es, %fs, %gs -> dodatni data segmentni registri (manje bitni, rijetko se koriste)

U real modu operacije stranicenja nema, tako da je linearna adresa zapravo fizicka adresa.
Pri pristupu memoriji, ukoliko se ne navede segmentni registar koji zelimo koristiti assembler ce to uraditi za nas (npr.: movw %ax, %ss:12(%esp)).

Instukcije za kontrolu toka koriste %cs.
stack instrukcije koriste %ss.
Vecina load/store instrukcija koriste %ds.


REAL MODE ADRESIRANJE:
Adresni prostor se dijeli na segmente (kontinualne dijelove memorije po 64kB).
Segmenti su unaprijed definisani u real modu operacije (ne definisemo mi) fiksne velicine.
Adresni prostor je 2^20. Imamo 2^16 segmenata po 2^16 bajta.
Pocetak svakog segmenta je unaprijed definisan na taj nacin da prvi pocinje na 0B, drugi na 16B, treci na 32B, itd.

Broj u segmentnom registru govori koji segment koristimo, a offset govori kojem bajtu unutar tog segmenta pristupamo.
U asembleru konstanta se ne moze direktno ubaciti u segmentni registar.


PROTECTED MODE ADRESIRANJE:
Mi definisemo segmente, i to na takav nacin da mi biramo koliko zelimo imat broj segmenata i njihovu velicinu.
Mozemo konfigurisat segmente na takav nacin da kazemo hocel oni imat executable (izvrsiv) kod, da li ce biti read-only, read-write, itd.
Logika nalaze da moramo imati bar jedan segment.
Ako zelimo da koristimo %cs (promjenu toka programa) moramo koristiti segment koji je read-only (non-writable) i executable.
Ako zelimo da koristimo %ss (pristup stack-u) moramo koristiti segment koji je writable i non-executable.

U protected modu segmentni registri se zovu selektori.
Svaki segment mora imati deskriptor.
Deskriptor je 64-bitna struktura i ima odredjena polja.
P bit govori da li je deskriptor validan (ako je 1 onda je validan, ako je 0 onda nije validan i ne koristi se).
Deskriptori se stavljaju u tabelu segmenata koja je u memoriji, ta tabela se naziva GDT (General Descriptor Table).
Prvi deskriptor mora biti sve nule, sto znaci da za dva segmenta moramo imat tri deskriptora.
G bit govori kako se limit interpretira (ako je 0 onda se interpretira kao 20 bitna vrijednost, 
ako je 1 limit se uzme takav kakav jest i shifta se 12 bita ulijevo cime se dobija 32 bitna adresa).
AVL i DPL diktiraju permisije (readable, writable, executable...).

Segmentni registri se dijele na tri polja: index (13b), T (1b) i RPL (Requested Privilege Level, 2b).
Postoje dvije deskriptor tabele, globalna (GDT) i lokalna (LDT), ali cemo mi samo koristiti GDT.

U %ss i %ds cemo unijeti indeks 2, jer ce nam drugi segment biti writable, non-executable.
U %cs cemo unijeti indeks 1, jer ce nam prvi segment biti read-only, executable.
Na Intel platformi postoje 4 nivoa privilegovanosti (jer je RPL 2 bita), gdje je 0 najprivilegovaniji, a 3 najmanje privilegovan.
GDTR (Global Descriptor Table Register) govori gdje se nalazi GDT.
GDTR sprema 32 bita za base (adresa pocetka tabele) i 16 bita za limit (govori velicinu tabele).
Jedan pristup memoriji je zapravo dva puta pristupati memoriji, prvi put u GDT da dobijemo deskriptor, a zatim do zeljene adrese.
Ovo je prevelik trosak, pa zato se zadnji pristupani deskriptor kesira za brzi pristup.


BIOS ROM je 40kB flash memorija koja se nalazi na samoj maticnoj ploci.
Pri dobijanju napajanja svi registri procesora su na proizvoljnim vrijednostima osim registara %ip i %cs.
%cs mora biti postavljen tako da odabere segment u kojem je dio memorije koji pristupa BIOS ROM-u.
%isp je postavljen tako da izvrsava prvu instrukciju koju zelimo izvrsiti unutar BIOS ROM-a.
Kljucna stvar koja u BIOS-u se moze uraditi je definirati sta je boot uredjaj.
Boot uredjaji su uredjaji trajne pohrane podataka (SSD, HDD, USB flash drive...) koji se zovu i block uredjaji.
Pri pokretanju racunara, ukoliko odlucimo ne mijenjati postavke BIOS-a, BIOS pronalazi prvi blok (sektor) boot uredjaja (blokovi su po 512B).
Prvi blok uredjaja se naziva boot segment i tu se nalazi program koji se zove bootloader.
BOIS procita prvi segment, ucita ga kompletan u memoriju na tacno odredjenu lokaciju odakle se pocinje izvrsavat bootloader.
Zadatak bootloadera je da pronadje kernel, podesi sve sto treba i nakon kompletnog ucitavanja operativnog sistema 
kontrola se predaje korisniku (npr. login screen na visekorisnickim sistemima).
